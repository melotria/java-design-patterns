---
title: Adapter
category: Structural
language: ta
tag:
 - Gang of Four
---

## இதுவும் அறியப்படுகிறது

* ரேப்பர்

## நோக்கம்

ஒரு வகுப்பின் இடைமுகத்தை வாடிக்கையாளர்கள் எதிர்பார்க்கும் மற்றொரு இடைமுகமாக மாற்றுகிறது, இது இணக்கத்தன்மையை செயல்படுத்துகிறது.

## விளக்கம்

உண்மை உலக உதாரணம்

> உங்கள் மெமரி கார்டில் சில படங்கள் உள்ளன என்று வைத்துக்கொள்வோம், அவற்றை உங்கள் கணினிக்கு மாற்ற வேண்டும். அவற்றை மாற்ற, உங்கள் கணினி துறைமுகங்களுடன் பொருந்தக்கூடிய ஏதாவது ஒரு அடாப்டர் தேவை, இதனால் நீங்கள் மெமரி கார்டை உங்கள் கணினியுடன் இணைக்க முடியும். இந்த சூழலில் கார்டு ரீடர் ஒரு அடாப்டர் ஆகும். மற்றொரு உதாரணம் பிரபலமான பவர் அடாப்டர் ஆகும்; மூன்று கால் செருகியை இரண்டு-முனை அவுட்லெட்டுடன் இணைக்க முடியாது, இது இரண்டு-முனை அவுட்லெட்களுடன் பொருந்தக்கூடிய பவர் அடாப்டரைப் பயன்படுத்த வேண்டும். இன்னொரு உதாரணம் ஒரு மொழிபெயர்ப்பாளர் ஒரு நபர் பேசும் வார்த்தைகளை மற்றொருவருக்கு மொழிபெயர்ப்பது.

எளிய வார்த்தைகளில்

> அடாப்டர் பேட்டர்ன் ஒரு பொருந்தாத பொருளை அடாப்டரில் சுற்றி, அதை மற்றொரு வகுப்புடன் பொருந்தக்கூடியதாக மாற்ற அனுமதிக்கிறது.

விக்கிபீடியா கூறுகிறது

> மென்பொருள் பொறியியலில், அடாப்டர் பேட்டர்ன் என்பது ஒரு மென்பொருள் வடிவமைப்பு முறையாகும், இது ஏற்கனவே உள்ள வகுப்பின் இடைமுகத்தை மற்றொரு இடைமுகமாகப் பயன்படுத்த அனுமதிக்கிறது. இது பெரும்பாலும் ஏற்கனவே உள்ள வகுப்புகளை அவற்றின் மூல குறியீட்டை மாற்றாமல் மற்றவற்றுடன் வேலை செய்ய பயன்படுத்தப்படுகிறது.

**நிரலாக்க உதாரணம்**

ஒரு துடுப்பு படகை மட்டுமே பயன்படுத்தக்கூடிய ஒரு கேப்டனை கருத்தில் கொள்ளுங்கள், ஆனால் அவரால் பாய்மரக்கப்பல் ஓட்ட முடியாது.

முதலில், நமக்கு `RowingBoat` மற்றும் `FishingBoat` இடைமுகங்கள் உள்ளன

```java
public interface RowingBoat {
    void row();
}

@Slf4j
public class FishingBoat {
    public void sail() {
        LOGGER.info("The fishing boat is sailing");
    }
}
```

கேப்டன் நகர்வதற்கு `RowingBoat` இடைமுகத்தின் செயல்படுத்தலை எதிர்பார்க்கிறார்.

```java
public class Captain {

    private final RowingBoat rowingBoat;

    // default constructor and setter for rowingBoat
    public Captain(RowingBoat rowingBoat) {
        this.rowingBoat = rowingBoat;
    }

    public void row() {
        rowingBoat.row();
    }
}
```

இப்போது, கடற்கொள்ளையர்கள் வருகிறார்கள் என்று வைத்துக்கொள்வோம், நமது கேப்டன் தப்பிக்க வேண்டும், ஆனால் ஒரு மீன்பிடி படகு மட்டுமே கிடைக்கிறது. கேப்டன் தனது துடுப்பு படகு திறன்களுடன் மீன்பிடி படகை இயக்க அனுமதிக்கும் ஒரு அடாப்டரை நாம் உருவாக்க வேண்டும்.

```java
@Slf4j
public class FishingBoatAdapter implements RowingBoat {

    private final FishingBoat boat;

    public FishingBoatAdapter() {
        boat = new FishingBoat();
    }

    @Override
    public void row() {
        boat.sail();
    }
}
```

இப்போது `Captain` கடற்கொள்ளையர்களிடமிருந்து தப்பிக்க `FishingBoat` ஐப் பயன்படுத்தலாம்.

```java
public static void main(final String[] args) {
    // The captain can only operate rowing boats but with adapter he is able to
    // use fishing boats as well
    var captain = new Captain(new FishingBoatAdapter());
    captain.row();
}
```

நிரல் வெளியீடு:

```
10:25:08.074 [main] INFO com.iluwatar.adapter.FishingBoat -- The fishing boat is sailing
```

## பயன்பாடு

அடாப்டர் பேட்டர்னை பயன்படுத்துங்கள்:

* நீங்கள் ஏற்கனவே உள்ள ஒரு வகுப்பைப் பயன்படுத்த விரும்புகிறீர்கள், மற்றும் அதன் இடைமுகம் உங்களுக்குத் தேவையான ஒன்றுடன் பொருந்தவில்லை
* நீங்கள் தொடர்பற்ற அல்லது எதிர்பாராத வகுப்புகளுடன் ஒத்துழைக்கும் ஒரு மறுபயன்பாட்டு வகுப்பை உருவாக்க விரும்புகிறீர்கள், அதாவது, அவசியம் பொருந்தக்கூடிய இடைமுகங்களைக் கொண்டிராத வகுப்புகள்
* நீங்கள் பல ஏற்கனவே உள்ள துணை வகுப்புகளைப் பயன்படுத்த வேண்டும், ஆனால் ஒவ்வொருவரையும் துணை வகுப்பாக்குவதன் மூலம் அவற்றின் இடைமுகத்தை தழுவுவது நடைமுறைக்கு ஏற்றதல்ல. ஒரு பொருள் அடாப்டர் அதன் பெற்றோர் வகுப்பின் இடைமுகத்தை தழுவ முடியும்.
* மூன்றாம் தரப்பு நூலகங்களைப் பயன்படுத்தும் பெரும்பாலான பயன்பாடுகள் பயன்பாட்டிற்கும் மூன்றாம் தரப்பு நூலகத்திற்கும் இடையே ஒரு நடுத்தர அடுக்காக அடாப்டர்களைப் பயன்படுத்துகின்றன, இது பயன்பாட்டை நூலகத்திலிருந்து பிரிக்கிறது. வேறொரு நூலகத்தைப் பயன்படுத்த வேண்டியிருந்தால், பயன்பாட்டு குறியீட்டை மாற்ற வேண்டிய அவசியமில்லாமல் புதிய நூலகத்திற்கான அடாப்டர் மட்டுமே தேவைப்படுகிறது.

## நன்மைகள்

* ஏற்கனவே உள்ள வகுப்புகளை மறுபயன்பாடு செய்ய அனுமதிக்கிறது, அவற்றின் குறியீட்டை மாற்ற வேண்டிய அவசியமில்லை
* பொருந்தாத இடைமுகங்களைக் கொண்ட வகுப்புகளை ஒன்றாக வேலை செய்ய அனுமதிக்கிறது
* பயன்பாட்டை மூன்றாம் தரப்பு நூலகங்களிலிருந்து பிரிக்கிறது

## குறைபாடுகள்

* கூடுதல் பொருள்களையும் வகுப்புகளையும் அறிமுகப்படுத்துகிறது, இது அமைப்பை சிக்கலாக்கலாம்
* சில சந்தர்ப்பங்களில், ஒரு வகுப்பை மறுவடிவமைப்பது எளிதாக இருக்கலாம்

## தெரிந்த பயன்பாடுகள்

* java.io.InputStreamReader
* java.io.OutputStreamWriter
* java.util.Arrays#asList()
* java.util.Collections#list()
* java.util.Collections#enumeration()
* javax.xml.bind.annotation.adapters.XMLAdapter

## தொடர்புடைய முறைகள்

* [Bridge](https://java-design-patterns.com/patterns/bridge/)
* [Decorator](https://java-design-patterns.com/patterns/decorator/)
* [Proxy](https://java-design-patterns.com/patterns/proxy/)

## மேலும் தகவல்

* [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.amazon.com/gp/product/0201633612/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0201633612&linkCode=as2&tag=javadesignpat-20&linkId=675d49790ce11db99d90bde47f1aeb59)
* [Head First Design Patterns: A Brain-Friendly Guide](https://www.amazon.com/gp/product/0596007124/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596007124&linkCode=as2&tag=javadesignpat-20&linkId=6b8b6eea86021af6c8e3cd3fc382cb5b)